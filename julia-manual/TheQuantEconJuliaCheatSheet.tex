% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}
\usepackage{amsfonts}
\usepackage{longtable}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{The QuantEcon Julia Cheat Sheet}
\date{January 17, 2017}
\release{}
\author{QuantEcon}
\newcommand{\sphinxlogo}{\includegraphics{qe-logo.png}\par}
\renewcommand{\releasename}{}

\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{julia-cheatsheet::doc}



\chapter{Variables}
\label{julia-cheatsheet:julia-cheatsheet}\label{julia-cheatsheet:variables}\label{julia-cheatsheet:id1}
Here are a few examples of basic kinds of variables we might be interested in creating.

\begin{longtable}{|p{0.475\linewidth}|p{0.475\linewidth}|}
\hline
\textsf{\relax 
Command
} & \textsf{\relax 
Description
}\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{l+m+mf}{4.1}
\PYG{n}{B} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{C} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.1} \PYG{l+m+mf}{2.2} \PYG{l+m+mf}{3.3}\PYG{p}{]}
\PYG{n}{D} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{\PYGZsq{}}
\PYG{n}{E} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{]}
\end{OriginalVerbatim}
 & 
How to \textbf{create a scalar, a vector, or a matrix}. Here, each example will result in a slightly different form
of output. \code{A} is a scalar, \code{B} is a flat array with 3 elements, \code{C} is a 1 by 3 vector, \code{D} is a 3 by
1 vector, and \code{E} is a 2 by 2 matrix.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is a string}\PYG{l+s}{\PYGZdq{}}
\end{OriginalVerbatim}
 & 
A \textbf{string} variable
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{true}
\end{OriginalVerbatim}
 & 
A \textbf{Boolean} variable
\\
\hline\end{longtable}



\chapter{Vectors and Matrices}
\label{julia-cheatsheet:vectors-and-matrices}
These are a few kinds of special vectors/matrices we can create and some things we can do with them.

\begin{longtable}{|p{0.475\linewidth}|p{0.475\linewidth}|}
\hline
\textsf{\relax 
Command
} & \textsf{\relax 
Description
}\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\end{OriginalVerbatim}
 &
 Creates a \textbf{matrix of all zeros} of size \code{m} by \code{n}. We can also do the following:  \leavevmode
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}
\end{OriginalVerbatim}

which will create a matrix of all zeros with the same dimensions as matrix or vector \code{B}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{ones}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\end{OriginalVerbatim}
 &
Creates a \textbf{matrix of all ones} of size \code{m} by \code{n}. We can also do the following: \leavevmode
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{ones}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}
\end{OriginalVerbatim}


which will create a matrix of all ones with the same dimensions as matrix or vector \code{B}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{eye}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{OriginalVerbatim}
 &
Creates an \code{n} by \code{n} \textbf{identity matrix}. For example, \code{eye(3)} will return $\begin{pmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1
\end{pmatrix}$
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{j}\PYG{p}{:}\PYG{n}{k}\PYG{p}{:}\PYG{n}{n}
\end{OriginalVerbatim}
 & 
This will create a \textbf{sequence} starting at \code{j}, ending at \code{n}, with difference
\code{k} between points. For example, \code{A = 2:4:10} will create the sequence \code{2, 6, 10}
To convert the output to an array, use \code{collect(A)}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{linspace}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
This will create a \textbf{sequence} of \code{m} points starting at \code{j}, ending at \code{n}. For example,
\code{A = linspace(2, 10, 3)} will create the sequence \code{2.0, 6.0, 10.0}. To convert the output to an
array, use \code{collect(A)}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{diagm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{OriginalVerbatim}
 &
Creates a \textbf{diagonal matrix} using the elements in \code{x}.  For example if \code{x = {[}1, 2, 3{]}}, \code{diagm(x)} will return
$\begin{pmatrix}
1 & 0 & 0\\
0 & 2 & 0\\
0 & 0 & 3
\end{pmatrix}$
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{rand}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
Creates an \code{m} by \code{n} \textbf{matrix of random numbers} drawn from a \textbf{uniform distribution} on
\([0, 1]\). Alternatively, \code{rand} can be used to draw random elements from a set \code{X}. For
example, if \code{X = {[}1, 2, 3{]}}, \code{rand(X)} will return either \code{1}, \code{2}, or \code{3}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
Creates an \code{m} by \code{n} \textbf{matrix of random numbers} drawn from a \textbf{standard normal distribution}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{]}
\end{OriginalVerbatim}
 & 
This is the general syntax for \textbf{accessing elements} of an array or matrix, where \code{m} and \code{n} are
integers. The example here returns the element in the second row and third column.
\begin{itemize}
\item {} 
We can also use ranges (like \code{1:3}) in place of single numbers to extract multiple rows or columns

\item {} 
A colon, \code{:}, by itself indicates all rows or columns

\item {} 
The word \code{end} can also be used to indicate the last row or column

\end{itemize}
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{nrow}\PYG{p}{,} \PYG{n}{ncol} \PYG{o}{=} \PYG{n}{size}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
\textbf{Returns the number of rows and columns} in a matrix. Alternatively, we can do \leavevmode
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{nrow} \PYG{o}{=} \PYG{n}{size}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{OriginalVerbatim}
 and \leavevmode
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{ncol} \PYG{o}{=} \PYG{n}{size}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{OriginalVerbatim}

\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{diag}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
This function returns a vector of the \textbf{diagonal elements} of \code{A}
(i.e., \code{A{[}1, 1{]}, A{[}2, 2{]}}, etc...).
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{hcat}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
\textbf{Horizontally concatenates} two matrices or vectors. The example here would return $\begin{pmatrix}
1 & 2 & 3 & 4
\end{pmatrix}$
An alternative syntax is: \leavevmode
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}
\end{OriginalVerbatim}

For either of these commands to work, both matrices or vectors must have the same number of rows.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{vcat}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\end{OriginalVerbatim}
 &
\textbf{Vertically concatenates} two matrices or vectors. The example here would return $\begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}$
An alternative syntax is:
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;} \PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}
\end{OriginalVerbatim}

For either of these commands to work, both matrices or vectors must have the same number of columns.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{reshape}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
\textbf{Reshapes} matrix or vector \code{a} into a new matrix or vector, \code{A} with \code{m} rows
and \code{n} columns. For example \code{A = reshape(1:10, 5, 2)} would return
$\begin{pmatrix}
1 & 6 \\
2 & 7 \\
3 & 8 \\
4 & 9 \\
5 & 10
\end{pmatrix}$

For this to work, the number  of elements in \code{a} (number of rows times number of columns) must
equal \code{m * n}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\end{OriginalVerbatim}
 & 
\textbf{Converts matrix A to a vector.} For example, if \code{A = {[}1 2; 3 4{]}}, then \code{A{[}:{]}} will return
\begin{quote}
\begin{gather}
\begin{split}\begin{pmatrix}
1 \\
2 \\
3 \\
4
\end{pmatrix}\end{split}\notag
\end{gather}\end{quote}
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{flipdim}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}
\end{OriginalVerbatim}
 &
\textbf{Reverses} the vector or matrix \code{A} along dimension \code{d}. For example, if \code{A = {[}1 2 3; 4 5 6{]}}, \leavevmode
\code{flipdim(A, 1)\}}, will reverse the rows of \code{A} and return
$\begin{pmatrix}
4 & 5 & 6 \\
1 & 2 & 3
\end{pmatrix}$
\code{flipdim(A, 2)} will reverse the columns of \code{A} and return
$\begin{pmatrix}
3 & 2 & 1 \\
6 & 5 & 4
\end{pmatrix}$
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{repmat}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
\textbf{Repeats matrix} \code{A}, \code{m} times in the row direction and \code{n} in the column direction.
For example, if \code{A = {[}1 2; 3 4{]}}, \code{repmat(A, 2, 3)} will return
$\begin{pmatrix}
1 & 2 & 1 & 2 & 1 & 2 \\
3 & 4 & 3 & 4 & 3 & 4 \\
1 & 2 & 1 & 2 & 1 & 2 \\
3 & 4 & 3 & 4 & 3 & 4
\end{pmatrix}$
\\
\hline\end{longtable}



\chapter{Mathematical Functions}
\label{julia-cheatsheet:mathematical-functions}
Here, we cover some useful functions for doing math.

\begin{longtable}{|p{0.475\linewidth}|p{0.475\linewidth}|}
\hline
\textsf{\relax 
Command
} & \textsf{\relax 
Description
}\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5} \PYG{o}{+} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{5} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{5} \PYG{o}{/} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{5} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{5} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}
\end{OriginalVerbatim}
 & 
\textbf{Scalar arithmetic operations}: addition, subtraction, multiplication, division, power, remainder.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{+} \PYG{n}{B}
\PYG{n}{A} \PYG{o}{\PYGZhy{}} \PYG{n}{B}
\PYG{n}{A} \PYG{o}{.}\PYG{o}{*} \PYG{n}{B}
\PYG{n}{A} \PYG{o}{.}\PYG{o}{/} \PYG{n}{B}
\PYG{n}{A} \PYG{o}{.}\PYG{o}{\PYGZca{}} \PYG{n}{B}
\PYG{n}{A} \PYG{o}{.}\PYG{o}{\PYGZpc{}} \PYG{n}{B}
\end{OriginalVerbatim}
 & 
\textbf{Element-by-element operations} on matrices. This syntax applies the operation element-wise to
corresponding elements of the matrices.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{*} \PYG{n}{B}
\end{OriginalVerbatim}
 & 
When \code{A} and \code{B} are matrices, \code{*} will perform \textbf{matrix multiplication}, as long as the number
of columns in \code{A} is the same as the number of columns in \code{B}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
This function returns the \textbf{dot product/inner product} of the two vectors \code{A} and \code{B}. The two
vectors need to be dimensionless or column vectors.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{.}\PYG{o}{\PYGZsq{}}
\end{OriginalVerbatim}
 & 
This syntax returns the \textbf{transpose} of the matrix \code{A} (i.e., reverses the dimensions of \code{A}).
For example if $A = \begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}$
then \code{A.'} returns $\begin{pmatrix}
1 & 3 \\
2 & 4
\end{pmatrix}$.
If \code{A} contains complex numbers $A = \begin{pmatrix}
1-1i & 2+1i \\
3-2i & 4+2i
\end{pmatrix}$
then \code{A.'} returns $\begin{pmatrix}
1-1i & 3-2i \\
2+1i & 4+2i
\end{pmatrix}$
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A}\PYG{o}{\PYGZsq{}}
\end{OriginalVerbatim}
 & 
This syntax returns the \textbf{complex conjugate transpose} of the matrix \code{A}.
For example if \code{A} is a real matrix $A = \begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}$
then \code{A'} returns $\begin{pmatrix}
1 & 3 \\
2 & 4
\end{pmatrix}$
If \code{A} contains complex numbers $A = \begin{pmatrix}
1-1i & 2+1i \\
3-2i & 4+2i
\end{pmatrix}$
then \code{A'} returns $\begin{pmatrix}
1+1i & 3+2i \\
2-1i & 4-2i
\end{pmatrix}$
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{sum}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{maximum}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{minimum}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
These functions compute the \textbf{sum, maximum, and minimum} elements, respectively, in matrix or vector
\code{A}. We can also add an additional argument for the dimension to compute the sum/maximum/minumum
across. For example \code{sum(A, 2)} will compute the row sums of \code{A} and \code{maximum(A, 1)} will compute
the maxima of eachcolumn of \code{A}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{inv}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{OriginalVerbatim}
 &
This function returns the \textbf{inverse} of the matrix \code{A}. Alternatively, we can do: \leavevmode
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{\PYGZca{}} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{OriginalVerbatim}
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{det}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
This function returns the \textbf{determinant} of the matrix \code{A}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{val}\PYG{p}{,} \PYG{n}{vec} \PYG{o}{=} \PYG{n}{eig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
Returns the \textbf{eigenvalues} (\code{val}) and \textbf{eigenvectors} (\code{vec}) of matrix \code{A}. In the output,
\code{val{[}i{]}} is the eigenvalue corresponding to eigenvector \code{val{[}:, i{]}}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{norm}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
Returns the Euclidean \textbf{norm} of matrix or vector \code{A}. We can also provide an argument \code{p}, like
so:
\begin{quote}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{norm}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\end{OriginalVerbatim}
\end{quote}

which will compute the \code{p}-norm (the default \code{p} is 2). If \code{A} is a matrix, valid values of \code{p}
are \code{1, 2} and \code{Inf}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYGZbs{} \PYG{n}{b}
\end{OriginalVerbatim}
 & 
If \code{A} is square, this syntax \textbf{solves the linear system} \(Ax = b\). Therefore, it returns
\code{x} such that \code{A * x = b}. If \code{A} is rectangular, it \textbf{solves for the least-squares solution}
to the problem.
\\
\hline\end{longtable}



\chapter{Programming}
\label{julia-cheatsheet:programming}
The following are useful basics for Julia programming.

\begin{longtable}{|p{0.475\linewidth}|p{0.475\linewidth}|}
\hline
\textsf{\relax 
Command
} & \textsf{\relax 
Description
}\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} One line comment}

\PYG{c+cm}{\PYGZsh{}=}
\PYG{c+cm}{C}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{o}\PYG{c+cm}{c}\PYG{c+cm}{k}
\PYG{c+cm}{=\PYGZsh{}}
\end{OriginalVerbatim}
 & 
Two ways to make \textbf{comments}. Comments are useful for annotating code and explaining what it does.
The first example limits your comment to one line and the second example allows the comments to span
multiple lines between the \code{\#=} and \code{=\#}.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{k}{in} \PYG{n}{iterable}
   \PYG{c}{\PYGZsh{} do something}
\PYG{k}{end}
\end{OriginalVerbatim}
 & 
A \textbf{for loop} is used to perform a sequence of commands for each element in an iterable object,
such as an array. For example, the following for loop fills the vector \code{l} with the squares of the
integers from 1 to 3:
\begin{quote}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{l} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{N}
   \PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{2}
\PYG{k}{end}
\end{OriginalVerbatim}
\end{quote}
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}=} \PYG{n}{N}
   \PYG{c}{\PYGZsh{} do something}
\PYG{k}{end}
\end{OriginalVerbatim}
 & 
A \textbf{while loop} performs a sequence of commands as long as some condition is true. For example, the
following while loop achieves the same result as the for loop above
\begin{quote}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{l} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}=} \PYG{n}{N}
   \PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{2}
   \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{k}{end}
\end{OriginalVerbatim}
\end{quote}
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZlt{}=} \PYG{n}{N}
   \PYG{c}{\PYGZsh{} do something}
\PYG{k}{else}
   \PYG{c}{\PYGZsh{} do something else}
\PYG{k}{end}
\end{OriginalVerbatim}
 & 
An \textbf{if/else statement} performs commands if a condition is met. For example, the following squares
\code{x} if \code{x} is 5, and cubes it otherwise:
\begin{quote}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{5}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{2}
\PYG{k}{else}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{3}
\PYG{k}{end}
\end{OriginalVerbatim}
\end{quote}

We can also just have an if statement on its own, in which case it would square \code{x} if \code{x} is 5,
and do nothing otherwise.
\begin{quote}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{5}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{2}
\PYG{k}{end}
\end{OriginalVerbatim}
\end{quote}
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{fun}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}

\PYG{k}{function}\PYG{n+nf}{ }\PYG{n+nf}{fun}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
   \PYG{n}{ret} \PYG{o}{=} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{x}
   \PYG{k}{return} \PYG{n}{ret} \PYG{o}{+} \PYG{n}{y}
\PYG{k}{end}
\end{OriginalVerbatim}
 & 
These are two ways to define \textbf{functions}. Both examples here define equivalent functions.

The first method is for defining a function on one line. The name of the function is \code{fun} and it
takes two inputs, \code{x} and \code{y}, which are specified between the parentheses. The code after the
equals sign tells Julia what the output of the function is.

The second method is used to create functions of more than one line. The name of the function, \code{fun},
is specified right after \code{function}, and like the one-line version, has its arguments in
parentheses. The \code{return} statement specifies the output of the function.
\\
\hline
\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello world}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{OriginalVerbatim}
 & 
How to \textbf{print} to screen. We can also print the values of variables to screen:
\begin{quote}

\begin{OriginalVerbatim}[commandchars=\\\{\}]
\PYG{n}{println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The value of x is }\PYG{l+s+si}{\PYGZdl{}(}\PYG{l+s+si}{x}\PYG{l+s+si}{)}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{OriginalVerbatim}
\end{quote}
\\
\hline\end{longtable}




\renewcommand{\indexname}{Index}
\printindex
\end{document}
